            .include "tn13def.inc"	; Используем ATMega16
			.include "define.asm"	; Наши все определения переменных тут
			.include "macro.asm"	; Все макросы у нас тут

;============SSEG=============================================================
			.DSEG

Ant1:      .byte 1     ; Счетчик антидребезга 1
Ant2:      .byte 1     ; Счетчик антидребезга 2
Count1:    .byte 1     ; Счетчик задержки1
Count2:    .byte 1     ; Счетчик задержки2
Flag1:     .byte 1     ; Флаг антидребезга 1
Flag2:     .byte 1     ; Флаг антидребезга 2
But_set1:    .byte 1   ; Сообщение о нажатии кнопки 1
But_set2:    .byte 1   ; Сообщение о нажатии кнопки 2
T1state:   .byte  1   ; переменная состояния КА T1
T2state:   .byte  1   ; переменная состояния КА T2

;===========CSEG==============================================================
			.include "vectors.asm"	; Все вектора прерываний спрятаны в этом файле

;=============================================================================!
; Interrupts procs ===========================================================!
;=============================================================================!


;=============================================================================!
; Main code ==================================================================!
;=============================================================================!
Reset:		OUTI 	SPL,low(RAMEND) 		 ; Первым делом инициализируем стек
;			OUTI	SPH,High(RAMEND)								

			.include "init.asm"				 ; Все начальные инициализации тут.
;-----------------------------------------------------------------------------
;Инициализация КА

            LDI OSRG,0                                       			
            STS T1state,OSRG   		     ; Записываем в переменную состояния КА T1 0(выключено)
			LDI OSRG,0                                       			
            STS T2state,OSRG   		     ; Записываем в переменную состояния КА T2 0(выключено)
;-----------------------------------------------------------------------------
;Начало главного цикла
			
Main:
			SEI								 ; Разрешаем прерывания.
			wdr								 ; Reset Watch DOG (Если не "погладить" "собаку". то она устроит конец света в виде reset для процессора)
;-----------------------------------------------------------------------------
;Проверка счетчика задержки1
			LDS Temp1,Count1
			CPI Temp1,dev   		         ; Сравнение счетчика с порогом
			BREQ startcheck1		         ; Если равно, прыжок в начало опроса кнопки
			INC8M Count1     				 ; Инкремент счетчика задержки1
			RJMP endcheck1					 ; Если не равно, прыгаем в конец опроса кнопки
;Опрос кнопки 1
startcheck1:
			SBIC PINB,BUT1  				 ; Опрашиваем кнопку
			rjmp decAnt1                     ; Если ненажата, прыгаем на декремент
			INC8M Ant1       				 ; Инкремент счетчика
			LDS Temp1,Ant1
			CPI Temp1,anti1   		         ; Сравнение счетчика с порогом
			BRNE endcheck1			         ; Если не равно, прыжок в конец
			LDI temp1,anti1_0	             ; Пишем в счетчик антидребезга первоначальное значение (средину) 
			STS Ant1,temp1
			LDS temp1,Flag1          		 ; Проверяем флаг, сравниваем с 0
			CPI temp1,0
			BREQ endcheck1			         ; Если равно, прыжок в конец
			CLR8M Flag1					     ; Если не равно, ставим флаг в 0
			rjmp WrBut_set1                  ; Прыгаем на запись сообщения
decAnt1:	
 			DEC8M Ant1  				     ; Декремент счетчика
			LDS temp2,Ant1                   ; Сравнение счетчика с нулем
			CP temp2,ZERO
			BRNE endcheck1					 ; Если не равно, прыжок в конец
			LDI temp1,anti1_0              	 ; Пишем в счетчик антидребезга первоначальное значение (средину) 
			STS Ant1,temp1
			LDS temp1,Flag1          		 ; Проверяем флаг, сравниваем с 0
			CPI temp1,0
			BRNE endcheck1			         ; Если не равно, прыжок в конец
			LDI temp1,1     				 ; Если равно, ставим флаг в 1
			STS Flag1,temp1 
			rjmp endcheck1	                 ; Прыжок на выход 		
WrBut_set1:  
            LDI OSRG,1                       ; Запись сообщения                			
            STS But_set1,OSRG
			CLR8M Count1					 ; Обнуляем счетчик задержки1;
endcheck1:			
;-----------------------------------------------------------------------------
;Проверка счетчика задержки2
			LDS Temp1,Count2
			CPI Temp1,dev   		         ; Сравнение счетчика с порогом
			BREQ startcheck2		         ; Если равно, прыжок в начало опроса кнопки
			INC8M Count2     				 ; Инкремент счетчика задержки2
			RJMP endcheck2					 ; Если не равно, прыгаем в конец опроса кнопки
;Опрос кнопки 2
startcheck2:
			SBIC PINB,BUT2  				 ; Опрашиваем кнопку
			rjmp decAnt2                     ; Если ненажата, прыгаем на декремент
			INC8M Ant2       				 ; Инкремент счетчика
			LDS Temp1,Ant2
			CPI Temp1,anti1                  ; Сравнение счетчика с порогом
			BRNE endcheck2			         ; Если не равно, прыжок в конец
			LDI temp1,anti1_0	             ; Пишем в счетчик антидребезга первоначальное значение (средину) 
			STS Ant2,temp1
			LDS temp1,Flag2          		 ; Проверяем флаг, сравниваем с 0
			CPI temp1,0
			BREQ endcheck2			         ; Если равно, прыжок в конец
			CLR8M Flag2					     ; Если не равно, ставим флаг в 0
			rjmp WrBut_set2                  ; Прыгаем на запись сообщения
decAnt2:	
 			DEC8M Ant2  				     ; Декремент счетчика
			LDS temp2,Ant2                   ; Сравнение счетчика с нулем
			CP temp2,ZERO
			BRNE endcheck2					 ; Если не равно, прыжок в конец
			LDI temp1,anti1_0              	 ; Пишем в счетчик антидребезга первоначальное значение (средину) 
			STS Ant2,temp1
			LDS temp1,Flag2          		 ; Проверяем флаг, сравниваем с 0
			CPI temp1,0
			BRNE endcheck2			         ; Если не равно, прыжок в конец
			LDI temp1,1     				 ; Если равно, ставим флаг в 1
			STS Flag2,temp1 
			rjmp endcheck2	                 ; Прыжок на выход 		
WrBut_set2:  
            LDI OSRG,1                       ; Запись сообщения                			
            STS But_set2,OSRG
			CLR8M Count2					 ; Обнуляем счетчик задержки1;
endcheck2:
;-----------------------------------------------------------------------------
;КА T1
FSM_T1:
scanmes1:   LDS temp1, But_set1              ; Процедура сканирования сообщения КА		
            CPI temp1,2                      ; Сканируем сообщение и выбираем соответствующее состояние, либо выходим
            BRNE endfsm_T1
			LDS temp1,T1state      		     ; Проверяем состояние КА, сравниваем с 0
			CPI temp1,0
			BRNE setonoff0                   ; Если не равно, прыгаем на установку сосстояния в 0
			LDI temp1,1
			STS T1state,temp1                ; Если равно, устанавливаем состояние в 1
			RCALL BUT1on                     ; Выполняем процедуру вывода
			RJMP endfsm_T1                   ; Прыжок на выход 
setonoff0:
			CLR8M T1state                    ; Устанавливаем состояние в 0
			RCALL BUT1off                    ; Выполняем процедуру вывода						
endfsm_T1:
;-----------------------------------------------------------------------------
;КА T1
FSM_T2:
scanmes2:   LDS temp1, But_set2              ; Процедура сканирования сообщения КА		
            CPI temp1,2                      ; Сканируем сообщение и выбираем соответствующее состояние, либо выходим
            BRNE endfsm_T2
			LDS temp1,T2state      		     ; Проверяем состояние КА, сравниваем с 0
			CPI temp1,0
			BRNE setT2_0                     ; Если не равно, прыгаем на установку сосстояния в 0
			LDI temp1,1
			STS T2state,temp1                ; Если равно, устанавливаем состояние в 1
			RCALL BUT2on                     ; Выполняем процедуру вывода
			RJMP endfsm_T2                   ; Прыжок на выход 
setT2_0:
			CLR8M T2state                    ; Устанавливаем состояние в 0
			RCALL BUT2off                    ; Выполняем процедуру вывода						
endfsm_T2:
;-----------------------------------------------------------------------------
;Задача обработки сообщений для КА T1

            LDS temp1,But_set1		; Проверяем сообщение, сравниваем с 0
			CPI temp1,0
            BREQ ENDCH1             ; Если равно, прыгаем на выход
            CPI temp1,1             ; Затем сравниваем с 1        
            BREQ ACT1               ; Если сообщение не активно, прыгаем на активацию 
            CLR8M  But_set1         ; Если не то и не то, обнуляем и на выход
            RJMP ENDCH1
ACT1:            
            LDI OSRG,2              ; Здесь активируем                         			
            STS But_set1,OSRG
ENDCH1:
;-----------------------------------------------------------------------------
;Задача обработки сообщений для КА T2

            LDS temp1,But_set2		; Проверяем сообщение, сравниваем с 0
			CPI temp1,0
            BREQ ENDCH2             ; Если равно, прыгаем на выход
            CPI temp1,1             ; Затем сравниваем с 1        
            BREQ ACT2               ; Если сообщение не активно, прыгаем на активацию 
            CLR8M  But_set2         ; Если не то и не то, обнуляем и на выход
            RJMP ENDCH2
ACT2:            
            LDI OSRG,2              ; Здесь активируем                         			
            STS But_set2,OSRG
ENDCH2:
;----------------------------------------------------------------------------			 

;Заглушка
			RJMP Main              

			.include "out.asm" ;процедуры вывода индикации и сообщений


